# -*- coding: utf-8 -*-
"""Lab4KR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BqzpJoyaISS3C7OjnypYFpwrLP1bZjAl
"""

class State:
  N = 3
  M = 2

  def __init__(self, misionari = N, canibali = N, barca = -1):
    ''' Constructorul clasei State.

    :param misionari: cati misionari sunt pe malul stang
    :param canibali: cati canibali sunt pe malul stang
    :param barca: -1 daca se afla pe malul stang, 1 altfel
    '''
    self.misionari = misionari
    self.canibali = canibali
    self.barca = barca

  def __eq__(self, cls):
     return self.barca == cls.barca and \
     self.misionari == cls.misionari and self.canibali == cls.canibali

  def __str__(self):
    return 'Stare curenta:\n' + \
    f'{str(self.misionari)} misionari, ' + \
    f'{str(self.canibali)} canibali | ' + \
    f'{str(self.N - self.misionari)} misionari, ' + \
    f'{str(self.N - self.canibali)} canibali \n' + \
    f'Barca se afla pe malul {"stang" if self.barca == -1 else "drept"}\n'

  def __repr__(self):
    return ('({} {} {})').format(self.misionari, self.canibali, self.barca)

  def succesori(self):
    ''' Calculeaza lista succesorilor directi ai starii curente. 
    
    :return: lista starilor admisibile
    '''
    succesori = []

    # Calculez cati misionari si canibali sunt pe malul cu barca
    misionari = self.misionari if self.barca == -1 else self.N - self.misionari
    canibali = self.canibali if self.barca == -1 else self.N - self.canibali

    for locuri in range(1, self.M + 1):
      for locuriMisionari in range(misionari + 1):
        if locuriMisionari > locuri:
          continue

        # Verific sa existe cati canibali vreau sa plimb
        locuriCanibali = locuri - locuriMisionari
        if locuriCanibali < 0 or locuriCanibali > canibali:
          continue

        # Verific sa nu fie mancati misionari in barca
        if locuriCanibali > locuriMisionari and locuriMisionari > 0:
          continue

        # Verific sa nu fie mancati misionari pe malul de plecare
        if canibali - locuriCanibali > misionari - locuriMisionari and \
        misionari - locuriMisionari > 0:
          continue
        
        # Verific sa nu fie mancati misionari pe malul de sosire
        if (self.N - canibali) + locuriCanibali > \
        (self.N - misionari) + locuriMisionari and \
        (self.N - misionari) + locuriMisionari > 0:
          continue

        # Trucuri de notatie:
        stareCurenta = State(
            self.misionari + self.barca * locuriMisionari, 
            self.canibali + self.barca * locuriCanibali, 
            (-1) * self.barca)

        succesori.append(stareCurenta)

    return succesori

f = open("input.txt", "r")
State.N = int(f.readline())
State.M = int(f.readline())
f.close()

state = State(State.N, State.N, -1)
print(state)

import copy


class Node:
  def __init__(self, informatie, parinte = None, g=0, h=0):
    self.informatie = informatie
    self.parinte = parinte
    self.g = g
    self.h = h
    self.f = g+h

  def __str__(self):
    return str(self.informatie)

  def __repr__(self):
    return "({}, ({}), cost: {})".format(self.informatie, "->".join([ str(x) for x in self.drumRadacina()]), self.f)

  def __eq__(self, other):
    return self.informatie == other.informatie and self.f == other.f

  def __le__(self, other):
    return self.f <= other.f

  def drumRadacina(self):
    drum =[]
    nod = self
    while nod is not None:
      drum.append(nod)
      nod = nod.parinte
    return reversed(drum)

  def vizitat(self):
    nod = self.parinte
    while nod is not None:
      if nod.informatie == self.informatie:
        return True
      nod = nod.parinte
    return False

import copy 

class Graph:
  def __init__(self, noduriStart, noduriScop):
    ''' Constructorul clasei Graf. '''
    self.noduriStart =noduriStart
    self.noduriScop = noduriScop
    if not self.valideaza():
      exit(0)

  def scop(self, informatieNod):
    ''' Primeste o informatie de tip Nod si verifica daca e scop.

    :param informatieNod: informatia nodului de cautat
    :return: True daca nodul e scop, False altfel
    '''
    return informatieNod in self.noduriScop

  #ex1
  def succesori(self, nod):
    l = []
    for i, stiva in enumerate(nod.informatie):
      if not stiva:
        continue
      stive_intermediare = copy.deepcopy(nod.informatie)
      bloc = stive_intermediare[i].pop()
      for j, stiva_doi in enumerate(stive_intermediare):
        copie = copy.deepcopy(stive_intermediare)
        if i == j:
          continue
        copie[j].append(bloc)
        newNode = Node(copie, nod, nod.g+1, self.calculeaza_h(copie))
        if not newNode.vizitat():
          l.append(newNode)

    return l

  # ex3
  def estimeaza_h(self, nod, tip_euristica):
    if self.scop(nod.informatie):
      return 0
    elif tip_euristica == "banala":
      return 1
    elif tip_euristica == "euristica mutari":
      nb = float('inf')
      for scop in self.noduriScop:
          n = sum([1 for i in range(len(scop)) for j in range(len(nod.informatie)) if nod.informatie[j][-1] != scop[i][-1]])
          if n < nb:
              nb = n
      return nb
    elif tip_euristica == "euristica costurilor":
      costuri = []
      for scop in self.noduriScop:
        cost = 0
        for i in range(len(nod.informatie)):
          for j in range(len(nod.informatie[i])):
            if nod.informatie[i][j] != scop[i][j]:
              cost += abs(ord(nod.informatie[i][j]) - ord(scop[i][j]))
        costuri.append(cost)
      return min(costuri)
    elif tip_euristica == "neadmisibila":
        return 1000000
    else:
        return 0

  def calculeaza_h(self, informatieNod):
    return 0

  #2b)
  def valideaza(self):
    conditie1 = all([len(self.noduriStart) == len(scop) for scop in self.noduriScop])
    blocuri = sorted(sum(self.noduriStart, start=[]))
    conditie2 = all([blocuri== sorted(sum(scop, start = [])) for scop in self.noduriScop])
    return conditie1 and conditie2

from google.colab import files
uploaded = files.upload()

#2a)

def calculeazaStive(sir_stive):
  lista_stive = sir_stive.split('\n')
  return [sir.strip().split() if sir!='.' else [] for sir in lista_stive]

f = open('input.txt', "r")
content = f.read()
[sir_start, sir_scopuri] = content.strip().split("===")
start = calculeazaStive(sir_start)
sir_scopuri = sir_scopuri.split("---")
scopuri = [calculeazaStive(sir) for sir in sir_scopuri]

print(start)
print(scopuri)
graf = Graph(start, scopuri)

#2c)

#BFS

def BFS(graf, n):
  coada = [Node(graf.nodStart)]
  while coada:
    nod = coada.pop(0)
    if graf.scop(nod.informatie):
      print(repr(nod))
      n-=1
      if n == 0:
        return
    drum = graf.succesori(nod)
    coada+=drum

#ex4 A* dupa pseudocod 

def expandeaza_nodul_curent(nod_curent, graf):
    """
    Funcție care expandează nodul curent și returnează o listă cu toți succesori săi validați.
    """
    succesori = []
    for stiva in nod_curent.informatie:
        if stiva: # daca stiva nu e goala
            for stiva_dest in nod_curent.informatie:
                if stiva != stiva_dest: # daca nu e aceeasi stiva
                    bloc = stiva[-1] # blocul de pe varful stivei
                    stiva_noua = stiva[:-1] # stiva fara blocul curent
                    stiva_dest_noua = stiva_dest + [bloc] # stiva destinatie cu blocul adaugat
                    informatie_noua = list(nod_curent.informatie) # copie a listei de stive
                    informatie_noua[informatie_noua.index(stiva)] = stiva_noua # actualizare lista stivelor
                    informatie_noua[informatie_noua.index(stiva_dest)] = stiva_dest_noua
                    succesor = Node(informatie_noua, parent=nod_curent, action=(bloc, stiva, stiva_dest))
                    succesori.append(succesor)
    return succesori





def a_star(graph):
    start_node = Node(graph.start_nodes, parent=None, g=0, h=graph.calculate_h(graph.start_nodes))
    open_list = [start_node]
    closed_list = []
    
    while open_list:
        current_node = min(open_list, key=lambda x: x.f)
        open_list.remove(current_node)

        if graph.goal_test(current_node.information):
            path = []
            node = current_node
            while node:
                path.insert(0, node.information)
                node = node.parent
            cost = current_node.g
            total_cost = current_node.f
            with open("output.txt", "w") as file:
                file.write(str(path) + "\n")
                file.write(str(cost) + "\n")
                file.write(str(total_cost) + "\n")
            return
        
        closed_list.append(current_node)

        for successor in expandeaza_nodul_curent(current_node, graph):
            if successor in closed_list:
                continue

            successor.g = current_node.g + graph.f
            successor.h = graph.calculeaza_h(successor.information)
            successor.f = successor.g + successor.h
            successor.parent = current_node

            if successor in open_list:
                if successor.f < open_list[open_list.index(successor)]:
                  open_list.remove(successor)
                else:
                  continue
            open_list.append(successor)