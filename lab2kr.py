# -*- coding: utf-8 -*-
"""Lab2KR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1URe1U7GJ0igff1qFSvcJKAisoGaveWLI
"""

class State:
  N=3
  M=2

  def __init__(self,canibali_stanga,misionari_stanga,barca):
    self.canibali_stanga = canibali_stanga
    self.misionari_stanga = misionari_stanga
    self.barca = barca

  def __eq__(self, elem):
    return (self.canibali_stanga, self.misionari_stanga, self.barca) == (elem.canibali_stanga, elem.misionari_stanga, elem.barca)

  def __str__(self):
        return f"Stare curentă:\n{self.misionari_stanga} misionari, {self.cannibali_stanga} canibali  | " \
               f"{State.N - self.misionari_stanga} misionari, {State.M - self.canibali_stanga} canibali\n" \
               f"Barca se află pe malul {'stâng' if self.barca == 0 else 'drept'}"

  def __repr__(self):
        return f"({self.misionari_stanga}, {self.canibali_stanga}, {self.barca})"

  @staticmethod
  def afisare_stare(stare):
      print(stare)

  def genereazaSuccesori(self):
    drum = []
    mal_curent = self.barca
    mal_opus = 1 - mal_curent
    for i in range(3):
      for j in range(3):
        if i + j < 1 or i + j > 2: # nu putem muta mai mult de 2 oameni
          continue
        if i > self.misionari_stanga or j > self.canibali_stanga: # nu putem muta mai mulți oameni decât avem pe malul stâng
          continue
        canibali_stanga_nou = self.canibali_stanga - j
        misionari_stanga_nou = self.misionari_stanga - i
        barca_noua = mal_opus
        if canibali_stanga_nou > misionari_stanga_nou and misionari_stanga_nou > 0: # trebuie să avem mai mulți misionari decât canibali pe malul stâng
          continue
        canibali_dreapta_nou = State.M - canibali_stanga_nou
        misionari_dreapta_nou = State.N - misionari_stanga_nou
        drum.append(State(canibali_stanga_nou, misionari_stanga_nou, barca_noua))
    return drum

class Nod:
  def __init__(self, informatie, parinte = None):
    self.informatie = informatie
    self.parinte = parinte

  def __str__(self):
    return str(self.informatie)

  def __repr__(self):
    return "({}, ({}))".format(self.informatie, "->".join([str(x) for x in self.drumRadacina()]))

  def drumRadacina(self):
    drum =[]
    nod = self
    while nod is not None:
      drum.append(nod)
      nod = nod.parinte
    return reversed(drum)

  def vizitat(self):
    nod = self.parinte
    while nod is not None:
      if nod.informatie == self.informatie:
        return True
      nod = nod.parinte
    return False

  def printDrumRadacina(nod):
    drum = [nod]
    while nod.parinte:
      drum.append(nod.parinte)
      nod = nod.parinte
    drum.reverse()
    for nod in drum:
      print(nod.informatie)

class Graph:
    def __init__(self, matrix, nodStart=0, nodScop=0):
        self.matrix=matrix
        self.nodStart = nodStart
        self.nodScop = nodScop

    def scop(self, informatie):
        return informatie in self.nodScop

    def succesori(self, nod):
        l=[]
        for i in range(len(self.matrix)):
            if self.matrix[nod.informatie][i]==1:
                newNod=Nod(i,nod)
                if not newNod.vizitat():
                    l.append(newNod)
        return l

#BFS

def BFS(graf, n):
  coada = [Nod(graf.nodStart)]
  while coada:
    nod = coada.pop(0)
    if graf.scop(nod.informatie):
      print(repr(nod))
      n-=1
      if n == 0:
        return
    drum = graf.succesori(nod)
    coada+=drum

import time

with open('date.out', "w") as f:
  start_time = time.time()
  nr_solutii = 2
  graf = Graph(Nod((3, 3, 1)))
  solutii = BFS(graf, nr_solutii)
  for solutie in solutii:
    printDrumRadacina(solutie)
    print("Timpul de rulare:", time.time() - start_time, "secunde.\n", file=f)